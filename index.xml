<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://lovzgump.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Jul 2019 14:20:30 +0800</lastBuildDate>
    
	<atom:link href="https://lovzgump.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Secondblog</title>
      <link>https://lovzgump.github.io/post/secondblog/</link>
      <pubDate>Mon, 01 Jul 2019 14:20:30 +0800</pubDate>
      
      <guid>https://lovzgump.github.io/post/secondblog/</guid>
      <description>Longset Substring Without Repeating Characters  A sliding window is an abstract concept commonly used in array/string problems.
Approach 1 Brute Force public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0; for (int i = 0; i &amp;lt; n; i++) for (int j = i + 1; j &amp;lt;= n; j++) if (allUnique(s, i, j)) ans = Math.max(ans, j - i); return ans; } public boolean allUnique(String s, int start, int end) { Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int i = start; i &amp;lt; end; i++) { Character ch = s.</description>
    </item>
    
    <item>
      <title>Firstblog</title>
      <link>https://lovzgump.github.io/post/firstblog/</link>
      <pubDate>Mon, 01 Jul 2019 12:46:22 +0800</pubDate>
      
      <guid>https://lovzgump.github.io/post/firstblog/</guid>
      <description>线性表 顺序表  用一组地址连续的存储空间依次存储线性表的数据元素  逻辑关系相邻的两个元素在物理位置上也相邻  读取元素时间复杂度为O(n)，插入、删除和按内容查找的时间复杂度为O(n^2) 局限：
 改变表的大小难 插入、删除元素平均需要移动一半的元素
链表  可以看做一组既存储数据又存储相互连接信息的结点集合
KMP 算法讲解
树 基本概念 基本性质
 树中的结点数等于其所有结点的度数加1 度为m的树，其第i层上至多有$ m^{i} $个结点，根节点为第0层 高度为h，度为m的树至多有$ {m^{h}-1}\over{m-1} $个结点(通过计算等比数列得到)
二叉树  完全二叉树：一棵高度为h的二叉树，除最后一层以外的其他所有层上的结点数都达到最大值，而最后一层上的所有结点分布在该层最左边的连续位置上
 满二叉树：一棵二叉树，如果其所有分支结点都有非空左子树和非空右子树，并且所有叶子节点都在同一层上
 二叉树的性质：
 任何一棵二叉树，度数为0的结点比度数为2的结点多一个  二叉树的遍历
 广度优先遍历：又叫层次遍历；通过队列实现，在访问一个节点后，将它的子结点按照从左往右的顺序依次入队，然后访问队列头部结点 深度优先遍历：  前序：每遇到一个结点，先访问该结点，并把该结点的非空右子树的根节点压入栈中，然后遍历其左子树，重复该过程直到当前访问过的结点没有左子树时停止，然后从栈顶弹出待访问的结点，继续遍历，直到栈为空时停止 中序：从根节点开始向左搜索，每遇到一个结点，就将其压入栈中，然后去遍历其左子树，遍历完左子树后，弹出栈顶结点并访问，然后遍历其右子树 后序：从根节点开始，向左搜索，每搜索到一个结点就将其压入栈中，直到压入栈中的结点不再有左子树为止。读取栈顶结点，如果该结点有右子树且未被访问，则访问其右子树，否则，访问该结点，并从栈中移除   二叉搜索树：该树的每个结点都有一个作为搜索依据的关键码，对任意结点，其左子树上的所有结点的关键码均小于该结点，其右子树上的所有结点的关键码均大于该结点
 删除：
 合并删除：查找到被删除结点p的左子树中按中序遍历的最后一个结点r，将r的右指针赋值为指向结点p的右子树的根节点，然后用p的左子树的根代替被删除的p 复制删除：选取一个合适的结点r，并将该结点的关键码复制给被删除结点p，然后将r删除；选取方法：p的左子树中最大的或右子树中最小的
平衡二叉树   平衡因子：结点的右子树的高度与左子树高度之差
 平衡二叉树：树中任意结点的平衡因子的绝对值不超过1；任一结点的左子树和右子树都是平衡的
 最大树：每个结点的值都大于或等于其子结点的值的树
 最大堆：最大的完全二叉树
 最大堆的插入 1 将新结点插入该树的最末尾的位置上 2 用该结点与其父结点进行比较，如果该结点的关键码大于父结点的关键码，则将两个结点位置交换 3 重复2步骤直到新结点的关键码不再大于父结点的关键码或者新结点成为根结点为止</description>
    </item>
    
  </channel>
</rss>