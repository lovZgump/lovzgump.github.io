<!doctype html>
<html lang="en-us">
  <head>
    <title>Firstblog // My New Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://lovzgump.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Firstblog"/>
<meta name="twitter:description" content="线性表 顺序表  用一组地址连续的存储空间依次存储线性表的数据元素  逻辑关系相邻的两个元素在物理位置上也相邻  读取元素时间复杂度为O(n)，插入、删除和按内容查找的时间复杂度为O(n^2) 局限：
 改变表的大小难 插入、删除元素平均需要移动一半的元素
链表  可以看做一组既存储数据又存储相互连接信息的结点集合
KMP 算法讲解
树 基本概念 基本性质
 树中的结点数等于其所有结点的度数加1 度为m的树，其第i层上至多有$ m^{i} $个结点，根节点为第0层 高度为h，度为m的树至多有$ {m^{h}-1}\over{m-1} $个结点(通过计算等比数列得到)
二叉树  完全二叉树：一棵高度为h的二叉树，除最后一层以外的其他所有层上的结点数都达到最大值，而最后一层上的所有结点分布在该层最左边的连续位置上
 满二叉树：一棵二叉树，如果其所有分支结点都有非空左子树和非空右子树，并且所有叶子节点都在同一层上
 二叉树的性质：
 任何一棵二叉树，度数为0的结点比度数为2的结点多一个  二叉树的遍历
 广度优先遍历：又叫层次遍历；通过队列实现，在访问一个节点后，将它的子结点按照从左往右的顺序依次入队，然后访问队列头部结点 深度优先遍历：  前序：每遇到一个结点，先访问该结点，并把该结点的非空右子树的根节点压入栈中，然后遍历其左子树，重复该过程直到当前访问过的结点没有左子树时停止，然后从栈顶弹出待访问的结点，继续遍历，直到栈为空时停止 中序：从根节点开始向左搜索，每遇到一个结点，就将其压入栈中，然后去遍历其左子树，遍历完左子树后，弹出栈顶结点并访问，然后遍历其右子树 后序：从根节点开始，向左搜索，每搜索到一个结点就将其压入栈中，直到压入栈中的结点不再有左子树为止。读取栈顶结点，如果该结点有右子树且未被访问，则访问其右子树，否则，访问该结点，并从栈中移除   二叉搜索树：该树的每个结点都有一个作为搜索依据的关键码，对任意结点，其左子树上的所有结点的关键码均小于该结点，其右子树上的所有结点的关键码均大于该结点
 删除：
 合并删除：查找到被删除结点p的左子树中按中序遍历的最后一个结点r，将r的右指针赋值为指向结点p的右子树的根节点，然后用p的左子树的根代替被删除的p 复制删除：选取一个合适的结点r，并将该结点的关键码复制给被删除结点p，然后将r删除；选取方法：p的左子树中最大的或右子树中最小的
平衡二叉树   平衡因子：结点的右子树的高度与左子树高度之差
 平衡二叉树：树中任意结点的平衡因子的绝对值不超过1；任一结点的左子树和右子树都是平衡的
 最大树：每个结点的值都大于或等于其子结点的值的树
 最大堆：最大的完全二叉树
 最大堆的插入 1 将新结点插入该树的最末尾的位置上 2 用该结点与其父结点进行比较，如果该结点的关键码大于父结点的关键码，则将两个结点位置交换 3 重复2步骤直到新结点的关键码不再大于父结点的关键码或者新结点成为根结点为止"/>

    <meta property="og:title" content="Firstblog" />
<meta property="og:description" content="线性表 顺序表  用一组地址连续的存储空间依次存储线性表的数据元素  逻辑关系相邻的两个元素在物理位置上也相邻  读取元素时间复杂度为O(n)，插入、删除和按内容查找的时间复杂度为O(n^2) 局限：
 改变表的大小难 插入、删除元素平均需要移动一半的元素
链表  可以看做一组既存储数据又存储相互连接信息的结点集合
KMP 算法讲解
树 基本概念 基本性质
 树中的结点数等于其所有结点的度数加1 度为m的树，其第i层上至多有$ m^{i} $个结点，根节点为第0层 高度为h，度为m的树至多有$ {m^{h}-1}\over{m-1} $个结点(通过计算等比数列得到)
二叉树  完全二叉树：一棵高度为h的二叉树，除最后一层以外的其他所有层上的结点数都达到最大值，而最后一层上的所有结点分布在该层最左边的连续位置上
 满二叉树：一棵二叉树，如果其所有分支结点都有非空左子树和非空右子树，并且所有叶子节点都在同一层上
 二叉树的性质：
 任何一棵二叉树，度数为0的结点比度数为2的结点多一个  二叉树的遍历
 广度优先遍历：又叫层次遍历；通过队列实现，在访问一个节点后，将它的子结点按照从左往右的顺序依次入队，然后访问队列头部结点 深度优先遍历：  前序：每遇到一个结点，先访问该结点，并把该结点的非空右子树的根节点压入栈中，然后遍历其左子树，重复该过程直到当前访问过的结点没有左子树时停止，然后从栈顶弹出待访问的结点，继续遍历，直到栈为空时停止 中序：从根节点开始向左搜索，每遇到一个结点，就将其压入栈中，然后去遍历其左子树，遍历完左子树后，弹出栈顶结点并访问，然后遍历其右子树 后序：从根节点开始，向左搜索，每搜索到一个结点就将其压入栈中，直到压入栈中的结点不再有左子树为止。读取栈顶结点，如果该结点有右子树且未被访问，则访问其右子树，否则，访问该结点，并从栈中移除   二叉搜索树：该树的每个结点都有一个作为搜索依据的关键码，对任意结点，其左子树上的所有结点的关键码均小于该结点，其右子树上的所有结点的关键码均大于该结点
 删除：
 合并删除：查找到被删除结点p的左子树中按中序遍历的最后一个结点r，将r的右指针赋值为指向结点p的右子树的根节点，然后用p的左子树的根代替被删除的p 复制删除：选取一个合适的结点r，并将该结点的关键码复制给被删除结点p，然后将r删除；选取方法：p的左子树中最大的或右子树中最小的
平衡二叉树   平衡因子：结点的右子树的高度与左子树高度之差
 平衡二叉树：树中任意结点的平衡因子的绝对值不超过1；任一结点的左子树和右子树都是平衡的
 最大树：每个结点的值都大于或等于其子结点的值的树
 最大堆：最大的完全二叉树
 最大堆的插入 1 将新结点插入该树的最末尾的位置上 2 用该结点与其父结点进行比较，如果该结点的关键码大于父结点的关键码，则将两个结点位置交换 3 重复2步骤直到新结点的关键码不再大于父结点的关键码或者新结点成为根结点为止" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lovzgump.github.io/post/firstblog/" />
<meta property="article:published_time" content="2019-07-01T12:46:22&#43;08:00"/>
<meta property="article:modified_time" content="2019-07-01T12:46:22&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://lovzgump.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>My New Hugo Site</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Firstblog</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 1, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h2 id="线性表">线性表</h2>

<h3 id="顺序表">顺序表</h3>

<ul>
<li>用一组地址连续的存储空间依次存储线性表的数据元素

<ul>
<li>逻辑关系相邻的两个元素在物理位置上也相邻</li>
</ul></li>
<li>读取元素时间复杂度为<code>O(n)</code>，插入、删除和按内容查找的时间复杂度为<code>O(n^2)</code></li>

<li><p>局限：</p>

<ul>
<li>改变表的大小难</li>

<li><p>插入、删除元素平均需要移动一半的元素</p>

<h3 id="链表">链表</h3></li>
</ul></li>

<li><p>可以看做一组既存储数据又存储相互连接信息的结点集合</p>

<h3 id="kmp">KMP</h3></li>

<li><p><a href="http://www.cnblogs.com/SYCstudio/p/7194315.html">算法讲解</a></p>

<h2 id="树">树</h2>

<h3 id="基本概念">基本概念</h3></li>

<li><p>基本性质</p>

<ul>
<li>树中的结点数等于其所有结点的度数加1</li>
<li>度为m的树，其第i层上至多有$ m^{i} $个结点，根节点为第0层</li>

<li><p>高度为h，度为m的树至多有$ {m^{h}-1}\over{m-1} $个结点(通过计算等比数列得到)</p>

<h3 id="二叉树">二叉树</h3></li>
</ul></li>

<li><p>完全二叉树：一棵高度为h的二叉树，除最后一层以外的其他所有层上的结点数都达到最大值，而最后一层上的所有结点分布在该层最左边的连续位置上</p></li>

<li><p>满二叉树：一棵二叉树，如果其所有分支结点都有非空左子树和非空右子树，并且所有叶子节点都在同一层上</p></li>

<li><p>二叉树的性质：</p>

<ul>
<li>任何一棵二叉树，度数为0的结点比度数为2的结点多一个</li>
</ul></li>

<li><p>二叉树的遍历</p>

<ul>
<li>广度优先遍历：又叫层次遍历；通过队列实现，在访问一个节点后，将它的子结点按照从左往右的顺序依次入队，然后访问队列头部结点</li>
<li>深度优先遍历：

<ul>
<li><code>前序</code>：每遇到一个结点，先访问该结点，并把该结点的非空右子树的根节点压入栈中，然后遍历其左子树，重复该过程直到当前访问过的结点没有左子树时停止，然后从栈顶<code>弹出</code>待访问的结点，继续遍历，直到栈为空时停止</li>
<li><code>中序</code>：从根节点开始向左搜索，每遇到一个结点，就将其压入栈中，然后去遍历其左子树，遍历完左子树后，<code>弹出</code>栈顶结点并访问，然后遍历其右子树</li>
<li><code>后序</code>：从根节点开始，向左搜索，每搜索到一个结点就将其压入栈中，直到压入栈中的结点不再有左子树为止。<code>读取</code>栈顶结点，如果该结点有右子树且未被访问，则访问其右子树，否则，访问该结点，并从栈中移除</li>
</ul></li>
</ul></li>

<li><p>二叉搜索树：该树的每个结点都有一个作为搜索依据的关键码，对任意结点，其左子树上的所有结点的关键码均小于该结点，其右子树上的所有结点的关键码均大于该结点</p>

<ul>
<li><p>删除：</p>

<ul>
<li>合并删除：查找到被删除结点p的左子树中按中序遍历的最后一个结点r，将r的右指针赋值为指向结点p的右子树的根节点，然后用p的左子树的根代替被删除的p</li>

<li><p>复制删除：选取一个合适的结点r，并将该结点的关键码复制给被删除结点p，然后将r删除；选取方法：p的左子树中最大的或右子树中最小的</p>

<h3 id="平衡二叉树">平衡二叉树</h3></li>
</ul></li>
</ul></li>

<li><p>平衡因子：结点的右子树的高度与左子树高度之差</p></li>

<li><p>平衡二叉树：树中任意结点的平衡因子的绝对值不超过1；任一结点的左子树和右子树都是平衡的</p></li>

<li><p>最大树：每个结点的值都大于或等于其子结点的值的树</p></li>

<li><p>最大堆：最大的<code>完全二叉树</code></p></li>

<li><p>最大堆的插入
1 将新结点插入该树的最末尾的位置上
2 用该结点与其父结点进行比较，如果该结点的关键码大于父结点的关键码，则将两个结点位置交换
3 重复2步骤直到新结点的关键码不再大于父结点的关键码或者新结点成为根结点为止</p></li>

<li><p>最大堆的删除
1 将完全二叉树最末尾结点m和结点p交换位置，删除结点p
2 创建过程的逆过程</p>

<h3 id="huffman编码">Huffman编码</h3></li>

<li><p>常用于数据通信和数据压缩领域，缩短编码总长，消除冗余数据</p></li>

<li><p>前缀编码：在变长编码方案中保证任一编码都不是另一编码的前缀</p>

<h3 id="森林">森林</h3></li>

<li><p>将一棵树转换为二叉树：</p>

<ul>
<li>树中所有相邻的兄弟结点之间加一条连线</li>
<li>对于树中的每个结点，只保留它与第一个孩子结点之间的连线</li>
</ul></li>

<li><p>将一个森林转换为二叉树：将森林中的每棵树转换为二叉树，保留第一棵二叉树不动，从第二棵开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子</p>

<h2 id="图">图</h2></li>

<li><p>图中的路径是由顶点和相邻顶点序偶构成的边所形成的序列</p></li>

<li><p>无向图的最大连通子图称为连通分量，任何连通图的连通分量只有一个，即本身，非连通图的连通分量有多个</p></li>

<li><p>一个连通图的生成树是图的极小连通子图</p></li>

<li><p>有向完全图一定是强连通有向图</p></li>

<li><p>一个图的边集和顶点集的子集不一定能构成原图的子图，因为可能边集中的某条边对应的某个顶点不在对应的顶点集中</p></li>

<li><p>对于连通无向图，边最少即构成一棵树；对于强连通有向图，边最少即构成一个有向环</p></li>

<li><p>若一个具有n个顶点。e条边的无向图是一个森林，则该森林中必有n-e棵树</p>

<ul>
<li>设森林中有x棵树，则再用x-1条边就能将所有树连成一棵树，此时有：边数+1=顶点数，即：e+(x-1)+1=n,  n=n-e</li>
</ul></li>

<li><p>邻接多重表是无向图的一种存储结构；十字链表是有向图的一种存储结构</p></li>

<li><p>图的遍历：建立在<code>记忆化搜索</code>基础上</p>

<ul>
<li>DFS：从图中某个顶点v出发，访问此顶点，然后依次从与v相邻且未被访问的邻接点u出发进行深度优先搜索，直至图中所有和v有路径相通的顶点都被访问到</li>
<li>前向边：在搜索过程中，由某个顶点v访问与其相邻且<code>未被访问的</code>顶点u时经过的边(v,u)</li>
</ul></li>

<li><p>对一个有n个顶点e条边的图采用邻接表表示，进行DFS遍历的时间复杂度为O(n+e)，空间复杂度为O(n)；
进行BFS遍历的时间复杂度为O(n+e)，空间复杂度O(n)</p></li>

<li><p>图的广度优先生成树的树高比深度优先生成树的树高小或相等</p></li>

<li><p>图的最小生成树不是唯一的，即最小生成树的树形不唯一，当图中的各边权值互不相等时，图的最小生成树唯一</p></li>

<li><p>Prim算法：时间复杂度为O(n^2)，适用于求解边稠密的图的最小生成树</p>

<ul>
<li><p>通过选择边(u,v)，使得(u,v)的权值是所有u在生成树中但v不在生成树中的权值最小者，从而找到新的顶点v并把它添加到生成树中</p>

<pre><code class="language-c++">void Prim() {
int index, j;
int Min, sum = 0;
for (int i = 1; i &lt;= N; i++)
dis[i] = map[1][i];
vis[1] = 1;
for (int i = 1; i &lt;= N; i++) {
Min = INF;
index = -1;
for (j = 1; j &lt;= N; j++) {
if (!vis[j] &amp;&amp; Min &gt; dis[j]) {
Min = dis[j];
index = j;
}
}
if (Min == INF)
break;
sum += Min;
vis[index] = 1;
for (j = 1; j &lt;= N; j++) {
if (!vis[j] &amp;&amp; dis[j] &gt; map[index][j])
dis[j] = map[index][j];
}
}
printf(&quot;%d\n&quot;, sum);
}
</code></pre>

<ul>
<li>Kruskal算法：时间复杂度为O(eloge)，适用于构造稀疏图的最小生成树</li>
<li>确定权值最小的边</li>
<li>判定一条边所关联的两个顶点是否在一个连通分量中</li>
<li>如果不是则合并两个顶点所属的连通分量
``` c++
int find(int x) {
if (p[x] == x)
return x;
return p[x] = find(p[x]);
}</li>
</ul>

<p>void Merge(int x, int y) {
x = find(x);
y = find(y);
if (x != y)
p[y] = x;
}</p>

<p>int Kruskal() {
for (int i = 1; i &lt;= N; i++)
p[i] = i;
ans = 0;
for (int i = 1; i &lt;= N * (N - 1) / 2; i++) {
if (find(e[i].s) != find(e[i].e)) {
Merge(e[i].s, e[i].e);
ans += e[i].w;
}
}
return ans;
}
```</p></li>
</ul></li>

<li><p>单元最短路径：Dijsktra算法</p></li>

<li><p>任意顶点对之间的最短路径：Floyd算法，是一种动态规划算法</p></li>

<li><p>拓扑排序：先找出任意一个没有入边的顶点，然后输出该顶点，并从图中删除该顶点和由它指出的边，修正其余顶点的入度信息</p></li>

<li><p>拓扑排序中，一般用栈暂存入度为0的顶点，如果两结点之间不存在祖先或子孙关系的话，则它们在拓扑排序中的关系是任意的，从而使用栈和队列都可以</p></li>

<li><p>有向无环图拓扑序列唯一，也并不能确定该图</p></li>
</ul>

<h2 id="查找">查找</h2>

<h3 id="散列">散列</h3>

<ul>
<li>散列函数的构造方法

<ul>
<li>直接定址法：H(key)=a*key+b, 该方法不会产生冲突，适合关键字分布基本连续的情况</li>
<li>除留余数法：H(key)=key%p</li>
<li>数字分析法、平方取中法、折叠法</li>
</ul></li>
<li>处理冲突的方法

<ul>
<li>开放地址法：Hi=(H(key)+di)%m

<ul>
<li>线性探查法：当冲突发生时，顺序查看表中下一个单元，直到找出一个空闲单元；缺点是会导致大量元素在相邻的散列地址上聚集，降低查找效率</li>
<li>二次探查法（平方探查法）：di=02，12，-12，22，-22&hellip;.；可以避免“堆积”问题，缺点是不能探测到散列上的所有元素</li>
<li>伪随机探查法</li>
<li>双散列探查法（再探查法）：Hi=(Hash(key)+i*ReHash(key))%m</li>
</ul></li>
<li>链接法（拉链法）</li>
<li>桶地址法</li>
</ul></li>
<li>散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子</li>
<li>装填因子=表中记录数/散列表长度</li>
</ul>

<h2 id="排序">排序</h2>

<ul>
<li><p>当关键字重复出现时，假设ki=kj，且在排序前的R序列中，ki领先于kj，若在排序后的序列R&rsquo;中ki仍领先于kj，在排序算法稳定，否则，排序算法是不稳定的</p>

<h3 id="插入排序">插入排序</h3></li>

<li><p>直接插入排序：时间复杂度为<code>O(n^2)</code>，且是稳定的排序算法</p>

<ul>
<li>由n-1趟排序组成，第p趟排序后保证从第0个位置到第p个位置上的元素为有序状态</li>
</ul></li>

<li><p>折半插入排序：时间复杂度为<code>O(n^2)</code>，且是稳定的排序算法</p></li>

<li><p>希尔排序：时间复杂度为<code>O(n^1.3)</code>，是不稳定的排序</p>

<h3 id="交换排序">交换排序</h3></li>

<li><p>冒泡排序：时间复杂度为<code>O(n^2)</code>，且是稳定的排序算法</p></li>

<li><p>快速排序： 最坏情况为待排序列有序时，时间复杂度为<code>O(n^2)</code>；最好情况是每次分割都是最平衡的，即轴元素两侧长度相同，时间复杂度为<code>O(nlongn)</code>；
快速排序的空间开销主要是递归调用时所使用的栈；不稳定的排序算法</p>

<ul>
<li>基于<code>分治法</code>的思想，包括分割、分治、合并三过程</li>
<li>分割策略一：首先从right所指位置向左搜索，找到第一个小于或等于轴的元素，把这个元素放到left所指的位置；再从left所指位置向右搜索，找到第一个大于轴的元素，把它放到right所指的位置，重复该过程，直到left==right</li>

<li><p>分割策略二：分别从待排序列的两边相向遍历，即从左往右遍历找到第一个大于轴的元素，从右往左遍历找到第一个小于或等于轴的元素，然后交换二者</p>

<h3 id="选择排序">选择排序</h3></li>
</ul></li>

<li><p>简单选择排序：利用线性查找的方法从一个序列中找到最小的元素，即第i趟的排序操作为：通过n-i次关键字比较，从n-i+1个元素中选出关键字最小的的元素，
并和第i-1个元素交换；时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code></p></li>

<li><p>堆排序</p></li>

<li><p>归并排序：时间复杂度为<code>O(nlongn)</code>，空间复杂度为<code>O(n)</code>，且是一个稳定的排序算法</p></li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
