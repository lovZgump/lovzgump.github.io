<!doctype html>
<html lang="utf-8">
  <head>
    <title>FirstBlog // 博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="http://lovzgump.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="FirstBlog"/>
<meta name="twitter:description" content=" 事务  事务：单个逻辑工作单元执行的一系列操作 事务的属性：ACID
 Atomicity原子性：单个事务内的一系列操作，要么全都执行，要么都不执行 Consistency一致性：事务在完成时，必须使所有的数据都保持一致状态  一致性状态：数据库只包含成功事务提交的结果 不一致状态：数据库中包含失败事务的结果  Isolation隔离性：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离，即每个事务都不会察觉到系统中其他事务在并发执行 Durability持久性：事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持
并发控制  事务并发执行可能带来的问题，可能会存取和存储不正确的数据，破坏事务的隔离性和数据库的一致性
 使并发事务的执行效果等同于串行执行的调度叫做可串行化；可串行性是并发事务正确性的唯一准则
 并发操作的潜在不一致性：
 丢失修改：事务1与事务2从数据库中读入同一数据并修改，事务2的提交结果破坏了事务1提交的结果，导致事务1的修改丢失 读“脏”数据：事务1修改某一数据，并将其写回磁盘。事务2读取同一数据后，事务1由于某些原因被撤销，这时事务1已修改过的数据恢复原值，事务2读到的数据就与数据库中的数据不一致，是不正确的数据，称为“脏”数据 不可重复读：是指事务1读取数据后，事务2执行更新操作，事务1无法再现前一次读取结果  封锁：事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁；是实现并发控制的一个非常重要的技术
 1级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放
 可防止丢失修改 没有限制读数据时加锁，所以不能保证可重复读和不读“脏”数据  2级封锁协议：1级封锁协议&#43;事务T在读取数据R前必须先加S锁，读完后即可释放S锁
 可防止丢失修改和读“脏”数据 由于读完数据后即可释放S锁，所以不能保证可重复读  3级封锁协议：1级封锁协议&#43;事务T在读取数据R之前必须先对其加S锁，直到事务结束时才释放
 封锁粒度：封锁对象的大小；多粒度封锁是指在一个系统中同时支持多种封锁粒度供不同的事务选择
 对一个结点加锁意味着这个结点的所有后裔结点加以同样类型的锁
 显示封锁：直接加到数据对象上的封锁 隐式封锁：由于其上级结点加锁而使该数据对象加上了锁 显式封锁和隐式封锁效果一样  意向锁：对任一结点加锁，必须先对它的上层结点加意向锁；用于提高对某个数据对象加锁时系统的检查效率
 申请封锁时应该按自上而下的次序进行 释放封锁时则应该按自下而上的次序进行  事务是恢复和并发控制的基本单位
故障恢复 事务故障：某个事务在运行过程中由于种种原因未运行至正常终止点就夭折了
 撤销undo事务 强行回滚该事务 清除该事务对数据库的所有修改，使得这个事务像根本没有启动过一样  系统故障：内存中数据库缓冲区的信息全部丢失
 清除尚未完成的事务对数据库的所有修改：系统重新启动时，恢复程序要强行撤销undo所有未完成事务 将缓冲区中已完成事务提交的结果写入数据库：系统重新启动时，恢复程序需要重做redo所有已提交的事务  介质故障
 日志文件：用来记录事务对数据库的更新操作的文件
  "/>

    <meta property="og:title" content="FirstBlog" />
<meta property="og:description" content=" 事务  事务：单个逻辑工作单元执行的一系列操作 事务的属性：ACID
 Atomicity原子性：单个事务内的一系列操作，要么全都执行，要么都不执行 Consistency一致性：事务在完成时，必须使所有的数据都保持一致状态  一致性状态：数据库只包含成功事务提交的结果 不一致状态：数据库中包含失败事务的结果  Isolation隔离性：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离，即每个事务都不会察觉到系统中其他事务在并发执行 Durability持久性：事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持
并发控制  事务并发执行可能带来的问题，可能会存取和存储不正确的数据，破坏事务的隔离性和数据库的一致性
 使并发事务的执行效果等同于串行执行的调度叫做可串行化；可串行性是并发事务正确性的唯一准则
 并发操作的潜在不一致性：
 丢失修改：事务1与事务2从数据库中读入同一数据并修改，事务2的提交结果破坏了事务1提交的结果，导致事务1的修改丢失 读“脏”数据：事务1修改某一数据，并将其写回磁盘。事务2读取同一数据后，事务1由于某些原因被撤销，这时事务1已修改过的数据恢复原值，事务2读到的数据就与数据库中的数据不一致，是不正确的数据，称为“脏”数据 不可重复读：是指事务1读取数据后，事务2执行更新操作，事务1无法再现前一次读取结果  封锁：事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁；是实现并发控制的一个非常重要的技术
 1级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放
 可防止丢失修改 没有限制读数据时加锁，所以不能保证可重复读和不读“脏”数据  2级封锁协议：1级封锁协议&#43;事务T在读取数据R前必须先加S锁，读完后即可释放S锁
 可防止丢失修改和读“脏”数据 由于读完数据后即可释放S锁，所以不能保证可重复读  3级封锁协议：1级封锁协议&#43;事务T在读取数据R之前必须先对其加S锁，直到事务结束时才释放
 封锁粒度：封锁对象的大小；多粒度封锁是指在一个系统中同时支持多种封锁粒度供不同的事务选择
 对一个结点加锁意味着这个结点的所有后裔结点加以同样类型的锁
 显示封锁：直接加到数据对象上的封锁 隐式封锁：由于其上级结点加锁而使该数据对象加上了锁 显式封锁和隐式封锁效果一样  意向锁：对任一结点加锁，必须先对它的上层结点加意向锁；用于提高对某个数据对象加锁时系统的检查效率
 申请封锁时应该按自上而下的次序进行 释放封锁时则应该按自下而上的次序进行  事务是恢复和并发控制的基本单位
故障恢复 事务故障：某个事务在运行过程中由于种种原因未运行至正常终止点就夭折了
 撤销undo事务 强行回滚该事务 清除该事务对数据库的所有修改，使得这个事务像根本没有启动过一样  系统故障：内存中数据库缓冲区的信息全部丢失
 清除尚未完成的事务对数据库的所有修改：系统重新启动时，恢复程序要强行撤销undo所有未完成事务 将缓冲区中已完成事务提交的结果写入数据库：系统重新启动时，恢复程序需要重做redo所有已提交的事务  介质故障
 日志文件：用来记录事务对数据库的更新操作的文件
  " />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://lovzgump.github.io/post/blog/" />
<meta property="article:published_time" content="2019-07-02T10:13:18&#43;08:00"/>
<meta property="article:modified_time" content="2019-07-02T10:13:18&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="http://lovzgump.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>博客</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">FirstBlog</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 2, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h2 id="事务">事务</h2>

<ul>
<li>事务：单个逻辑工作单元执行的一系列操作</li>

<li><p>事务的属性：ACID</p>

<ul>
<li>Atomicity原子性：单个事务内的一系列操作，要么全都执行，要么都不执行</li>
<li>Consistency一致性：事务在完成时，必须使所有的数据都保持一致状态

<ul>
<li>一致性状态：数据库只包含成功事务提交的结果</li>
<li>不一致状态：数据库中包含失败事务的结果</li>
</ul></li>
<li>Isolation隔离性：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离，即每个事务都不会察觉到系统中其他事务在并发执行</li>

<li><p>Durability持久性：事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持</p>

<h2 id="并发控制">并发控制</h2></li>
</ul></li>

<li><p>事务并发执行可能带来的问题，可能会存取和存储不正确的数据，破坏事务的隔离性和数据库的一致性</p></li>

<li><p>使并发事务的执行效果等同于串行执行的调度叫做<code>可串行化</code>；可串行性是并发事务正确性的唯一准则</p></li>

<li><p>并发操作的潜在不一致性：</p>

<ul>
<li>丢失修改：事务1与事务2从数据库中读入同一数据并修改，事务2的提交结果破坏了事务1提交的结果，导致事务1的修改丢失</li>
<li>读“脏”数据：事务1修改某一数据，并将其写回磁盘。事务2读取同一数据后，事务1由于某些原因被撤销，这时事务1已修改过的数据恢复原值，事务2读到的数据就与数据库中的数据不一致，是不正确的数据，称为“脏”数据</li>
<li>不可重复读：是指事务1读取数据后，事务2执行更新操作，事务1无法再现前一次读取结果</li>
</ul></li>

<li><p>封锁：事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁；是实现并发控制的一个非常重要的技术</p></li>

<li><p>1级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放</p>

<ul>
<li>可防止丢失修改</li>
<li>没有限制读数据时加锁，所以不能保证可重复读和不读“脏”数据</li>
</ul></li>

<li><p>2级封锁协议：1级封锁协议+事务T在读取数据R前必须先加S锁，读完后即可释放S锁</p>

<ul>
<li>可防止丢失修改和读“脏”数据</li>
<li>由于读完数据后即可释放S锁，所以不能保证可重复读</li>
</ul></li>

<li><p>3级封锁协议：1级封锁协议+事务T在读取数据R之前必须先对其加S锁，直到事务结束时才释放</p></li>

<li><p>封锁粒度：封锁对象的大小；多粒度封锁是指在一个系统中同时支持多种封锁粒度供不同的事务选择</p></li>

<li><p>对一个结点加锁意味着这个结点的所有后裔结点加以同样类型的锁</p>

<ul>
<li>显示封锁：直接加到数据对象上的封锁</li>
<li>隐式封锁：由于其上级结点加锁而使该数据对象加上了锁</li>
<li>显式封锁和隐式封锁效果一样</li>
</ul></li>

<li><p>意向锁：对任一结点加锁，必须先对它的上层结点加意向锁；用于提高对某个数据对象加锁时系统的检查效率</p>

<ul>
<li>申请封锁时应该按自上而下的次序进行</li>
<li>释放封锁时则应该按自下而上的次序进行</li>
</ul></li>

<li><p>事务是<code>恢复</code>和<code>并发控制</code>的基本单位</p>

<h2 id="故障恢复">故障恢复</h2></li>

<li><p>事务故障：某个事务在运行过程中由于种种原因未运行至正常终止点就夭折了</p>

<ul>
<li>撤销undo事务</li>
<li>强行回滚该事务</li>
<li>清除该事务对数据库的所有修改，使得这个事务像根本没有启动过一样</li>
</ul></li>

<li><p>系统故障：内存中数据库缓冲区的信息全部丢失</p>

<ul>
<li>清除尚未完成的事务对数据库的所有修改：系统重新启动时，恢复程序要强行撤销<code>undo</code>所有未完成事务</li>
<li>将缓冲区中已完成事务提交的结果写入数据库：系统重新启动时，恢复程序需要重做<code>redo</code>所有已提交的事务</li>
</ul></li>

<li><p>介质故障</p></li>

<li><p>日志文件：用来记录事务对数据库的更新操作的文件</p></li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
